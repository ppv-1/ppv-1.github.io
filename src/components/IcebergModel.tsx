/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/iceberg.glb -o src/components/IcebergModel.tsx 
Author: phaholyut_s (https://sketchfab.com/phaholyut_s)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/low-poly-iceberg-scene-d48e92e570204adbaac185d7920708be
Title: Low Poly Iceberg Scene
*/

import * as THREE from 'three'
import React from 'react'
import type { JSX } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame, useThree } from '@react-three/fiber'
import type { GLTF } from 'three-stdlib'

type ActionName = 'Iceberg|CylinderAction.001' | 'Iceberg|IcebergAction.002' | 'Small Platform|CylinderAction.001' | 'Small Platform|IcebergAction.002'

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName
}

type GLTFResult = GLTF & {
  nodes: {
    Iceberg_Iceberg_0: THREE.Mesh
    Small_Platform_Iceberg_0: THREE.Mesh
    Icosphere_Iceberg_0: THREE.Mesh
    Icosphere001_Iceberg_0: THREE.Mesh
    Icosphere002_Iceberg_0: THREE.Mesh
    Icosphere003_Iceberg_0: THREE.Mesh
    Icosphere004_Iceberg_0: THREE.Mesh
    Icosphere005_Iceberg_0: THREE.Mesh
    Icosphere006_Iceberg_0: THREE.Mesh
    Icosphere007_Iceberg_0: THREE.Mesh
    Icosphere008_Iceberg_0: THREE.Mesh
    Icosphere009_Iceberg_0: THREE.Mesh
    Icosphere010_Iceberg_0: THREE.Mesh
    Icosphere011_Iceberg_0: THREE.Mesh
    Icosphere012_Iceberg_0: THREE.Mesh
    Floor_Ground_0: THREE.Mesh
    Floor_Ground_0_1: THREE.Mesh
    Water_Water_0: THREE.Mesh
  }
  materials: {
    Iceberg: THREE.MeshStandardMaterial
    Ground: THREE.MeshStandardMaterial
    Water: THREE.MeshStandardMaterial
  }
  animations: GLTFAction[]
}

interface ModelProps {
  scroll: React.RefObject<{ current: number }>
}

export function Model({ scroll, ...props }: ModelProps & any) {
  const group = React.useRef<THREE.Group>(null)
  const oceanRef = React.useRef<THREE.Mesh>(null)
  const { nodes, materials } = useGLTF('/models/iceberg.glb') as unknown as GLTFResult
  const { camera } = useThree()
  
  // Create infinite ocean material
  const oceanMaterial = React.useMemo(() => {
    const material = new THREE.MeshStandardMaterial({
      color: new THREE.Color(0x006994), // Ocean blue
      transparent: true,
      opacity: 0.8,
      roughness: 0.1,
      metalness: 0.1,
    })
    return material
  }, [])

  // Define camera path points based on scroll progress
  const getCameraPosition = (progress: number) => {
    // Define 5 camera positions for 20% each
    const cameraPositions = [
      { position: [3, 2, 2], target: [0, 8, 1.5], distance: 0.5 }, // intro view, staring at sky
      { position: [3, 2, 2], target: [-2, -0.5, 1.5], distance: 0.5 }, // surface view
      { position: [-1, 1, -5], target: [0, -1, 0], distance: 0.7 }, // surface view from different angle
      { position: [1, -3, -5], target: [0, -1, 0], distance: 0.7 },     // Slightly underwater front view
      { position: [4, -7, 2], target: [0, -2.5, 0.5], distance: 0.5 },     // Underwater front view
    ];
    
    // Calculate which segment we're in based on scroll progress
    const segment = Math.min(Math.floor(progress * (cameraPositions.length - 1)), cameraPositions.length - 2);
    const localProgress = (progress * (cameraPositions.length - 1)) - segment;
    
    // Interpolate between current and next positions
    const current = cameraPositions[segment];
    const next = cameraPositions[segment + 1];
    
    const distance = THREE.MathUtils.lerp(current.distance, next.distance, localProgress);
    
    const scaledPosition = [
      THREE.MathUtils.lerp(current.position[0] * current.distance, next.position[0] * next.distance, localProgress),
      THREE.MathUtils.lerp(current.position[1] * current.distance, next.position[1] * next.distance, localProgress),
      THREE.MathUtils.lerp(current.position[2] * current.distance, next.position[2] * next.distance, localProgress)
    ] as [number, number, number];
    
    return {
      position: scaledPosition,
      target: [
        THREE.MathUtils.lerp(current.target[0], next.target[0], localProgress),
        THREE.MathUtils.lerp(current.target[1], next.target[1], localProgress),
        THREE.MathUtils.lerp(current.target[2], next.target[2], localProgress)
      ] as [number, number, number]
    };
  };
  
  // Update camera position and ocean following
  useFrame(() => {
    if (scroll.current) {
      const scrollProgress = scroll.current.current;
      const { position, target } = getCameraPosition(scrollProgress);
      
      // Smoothly move camera to new position
      camera.position.lerp(new THREE.Vector3(position[0], position[1], position[2]), 0.1);
      camera.lookAt(new THREE.Vector3(target[0], target[1], target[2]));
      
      // Make ocean follow camera for infinite effect
      if (oceanRef.current) {
        oceanRef.current.position.x = camera.position.x;
        oceanRef.current.position.z = camera.position.z;
      }
    }
  });

  return (
    <group ref={group} {...props} dispose={null}>
      {/* Infinite Ocean Plane */}
      <mesh
        ref={oceanRef}
        position={[0, 0, 0]} // At sea level
        rotation={[-Math.PI / 2, 0, 0]}
        material={oceanMaterial}
      >
        <planeGeometry args={[1000, 1000, 100, 100]} />
      </mesh>

      {/* Original Iceberg Model - but hide the original water */}
      <group name="Sketchfab_Scene">
        <group name="Sketchfab_model" rotation={[-Math.PI / 2, 0, 0]}>
          <group name="e630e7fd7a8040388f27e4b33bfb0044fbx" rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
            <group name="Object_2">
              <group name="RootNode">
                <group name="Iceberg" rotation={[-Math.PI / 2, 0, 0]} scale={100}>
                  <mesh name="Iceberg_Iceberg_0" geometry={nodes.Iceberg_Iceberg_0.geometry} material={materials.Iceberg} />
                </group>
                <group name="Small_Platform" rotation={[-Math.PI / 2, 0, 0]} scale={100}>
                  <mesh name="Small_Platform_Iceberg_0" geometry={nodes.Small_Platform_Iceberg_0.geometry} material={materials.Iceberg} />
                </group>
                
                {/* All the icosphere groups remain the same */}
                <group name="Icosphere" position={[330.588, -513.18, -354.134]} rotation={[-Math.PI / 2, 0, 0]} scale={[122.554, 122.554, 73.57]}>
                  <mesh name="Icosphere_Iceberg_0" geometry={nodes.Icosphere_Iceberg_0.geometry} material={materials.Iceberg} />
                </group>
                <group name="Icosphere001" position={[350.444, -487.539, -194.209]} rotation={[-2.213, 1.087, -0.198]} scale={-16.563}>
                  <mesh name="Icosphere001_Iceberg_0" geometry={nodes.Icosphere001_Iceberg_0.geometry} material={materials.Iceberg} />
                </group>
                <group name="Icosphere002" position={[369.924, -487.539, -210.147]} rotation={[-2.213, 1.087, -0.198]} scale={-8.717}>
                  <mesh name="Icosphere002_Iceberg_0" geometry={nodes.Icosphere002_Iceberg_0.geometry} material={materials.Iceberg} />
                </group>
                <group name="Icosphere003" position={[395.544, -509.706, 397.293]} rotation={[1.055, 0.568, 0.882]} scale={[85.065, 85.065, 51.065]}>
                  <mesh name="Icosphere003_Iceberg_0" geometry={nodes.Icosphere003_Iceberg_0.geometry} material={materials.Iceberg} />
                </group>
                <group name="Icosphere004" position={[-156.807, -522.941, 88.79]} rotation={[-Math.PI / 2, 0, 0]} scale={[39.474, 39.474, 58.634]}>
                  <mesh name="Icosphere004_Iceberg_0" geometry={nodes.Icosphere004_Iceberg_0.geometry} material={materials.Iceberg} />
                </group>
                <group name="Icosphere005" position={[-144.121, -523.984, 59.159]} rotation={[-Math.PI / 2, 0, 0]} scale={[29.039, 29.039, 43.885]}>
                  <mesh name="Icosphere005_Iceberg_0" geometry={nodes.Icosphere005_Iceberg_0.geometry} material={materials.Iceberg} />
                </group>
                <group name="Icosphere006" position={[-172.852, -493.634, 49.312]} rotation={[-Math.PI / 2, 0, 0]} scale={[22.204, 22.204, 13.828]}>
                  <mesh name="Icosphere006_Iceberg_0" geometry={nodes.Icosphere006_Iceberg_0.geometry} material={materials.Iceberg} />
                </group>
                <group name="Icosphere007" position={[341.026, -486.411, 367.591]} rotation={[-2.213, 1.087, -0.198]} scale={-9.494}>
                  <mesh name="Icosphere007_Iceberg_0" geometry={nodes.Icosphere007_Iceberg_0.geometry} material={materials.Iceberg} />
                </group>
                <group name="Icosphere008" position={[352.193, -484.157, 358.455]} rotation={[-2.213, 1.087, -0.198]} scale={-4.997}>
                  <mesh name="Icosphere008_Iceberg_0" geometry={nodes.Icosphere008_Iceberg_0.geometry} material={materials.Iceberg} />
                </group>
                <group name="Icosphere009" position={[328.804, -482.354, 385.303]} rotation={[-1.038, 1.123, -1.472]} scale={-11.777}>
                  <mesh name="Icosphere009_Iceberg_0" geometry={nodes.Icosphere009_Iceberg_0.geometry} material={materials.Iceberg} />
                </group>
                <group name="Icosphere010" position={[346.516, -482.887, 382.731]} rotation={[-1.038, 1.123, -1.472]} scale={-6.199}>
                  <mesh name="Icosphere010_Iceberg_0" geometry={nodes.Icosphere010_Iceberg_0.geometry} material={materials.Iceberg} />
                </group>
                <group name="Icosphere011" position={[-417.455, -488.61, 496.304]} rotation={[-2.213, 1.087, -0.198]} scale={-9.494}>
                  <mesh name="Icosphere011_Iceberg_0" geometry={nodes.Icosphere011_Iceberg_0.geometry} material={materials.Iceberg} />
                </group>
                <group name="Icosphere012" position={[-411.966, -485.087, 511.443]} rotation={[-1.038, 1.123, -1.472]} scale={-6.199}>
                  <mesh name="Icosphere012_Iceberg_0" geometry={nodes.Icosphere012_Iceberg_0.geometry} material={materials.Iceberg} />
                </group>
                
                <group name="Floor" rotation={[-Math.PI / 2, 0, 0]} scale={100}>
                  <mesh name="Floor_Ground_0" geometry={nodes.Floor_Ground_0.geometry} material={materials.Ground} />
                  <mesh name="Floor_Ground_0_1" geometry={nodes.Floor_Ground_0_1.geometry} material={materials.Ground} />
                </group>
                
                {/* Comment out or remove the original water to prevent conflicts */}
                {/* <group name="Water" rotation={[-Math.PI / 2, 0, 0]} scale={100}>
                  <mesh name="Water_Water_0" geometry={nodes.Water_Water_0.geometry} material={materials.Water} />
                </group> */}
              </group>
            </group>
          </group>
        </group>
      </group>
    </group>
  )
}

useGLTF.preload('/models/iceberg.glb')
